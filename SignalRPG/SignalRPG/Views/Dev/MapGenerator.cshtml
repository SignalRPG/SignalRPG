@{
    ViewBag.Title = "MapGenerator";
}

<h2>Map Generator</h2>

<div class="container-fluid">


    <div class="form-inline">
        <div class="form-group">
            <label for="map-name">Name</label>
            <input id="map-name" type="text" class="form-control" />
        </div>
        <div class="form-group">
            <label for="map-region">Region</label>
            <input id="map-region" type="text" class="form-control" />
        </div>
        <div class="form-group">
            <label for="map-width">Width</label>
            <input id="map-width" type="text" class="form-control" />
        </div>
        <div class="form-group">
            <label for="map-height">Height</label>
            <input id="map-height" type="text" class="form-control" />
        </div>

        <button id="generate" type="button" class="btn btn-default">Generate</button>
    </div>
    <hr />
    <div class="btn-toolbar" role="toolbar">
        <div class="pull-left">
            <label class="clearfix">Layers</label>
            <div id="toolbar-layers" class="btn-group" data-toggle="buttons">
                <label class="btn btn-default active">
                    <input type="radio" name="layers" class="btn btn-default" checked="checked" value="0" />1
                </label>

                <label class="btn btn-default">
                    <input type="radio" name="layers" class="btn btn-default" value="1" />2
                </label>

                <label class="btn btn-default">
                    <input type="radio" name="layers" class="btn btn-default" value="2" />3
                </label>

                <label class="btn btn-default">
                    <input type="radio" name="layers" class="btn btn-default" value="-1" />View
                </label>
            </div>
        </div>

        <div class="pull-left">
            <label class="clearfix">Drawing Tools</label>
            <div id="toolbar-commands" class="btn-group" data-toggle="buttons">
                <label class="btn btn-default active brush">
                    <input type="radio" name="commands" class="btn btn-default" checked="checked" value="brush" />Brush
                </label>

                <label class="btn btn-default">
                    <input type="radio" name="commands" class="btn btn-default" value="fill" />Fill
                </label>

                <label class="btn btn-default">
                    <input type="radio" name="commands" class="btn btn-default" value="erase" /><i class="fa fa-eraser"></i>
                </label>

                <label class="btn btn-default">
                    <input type="radio" name="commands" class="btn btn-default" value="clear" /><i class="fa fa-ban"></i>
                </label>

            </div>
        </div>
    </div>
    <br />
    <div class="row">
        <div class="col-xs-8">


            <div id="map-container">
                <canvas id="map"></canvas>
            </div>
            <button id="save-map" type="button">Save</button>
            <hr />
            <div id="map-json" class="well">

            </div>
        </div>
        <div class="col-xs-4">
            <select id="tileset-select" class="form-control">

            </select>
            <div class="clearfix">

                <div id="tileset-direction" class="pull-left">
                    <input id="direction-up" class="up" type="checkbox" />
                    <input id="direction-right" class="right" type="checkbox" />
                    <input id="direction-down" class="down" type="checkbox" />
                    <input id="direction-left" class="left" type="checkbox" />
                </div>

                <div id="tileset-priority" class="pull-left">
                    <label>
                        <input id="priority-below" type="radio" name="priority" value="0" /> Below
                    </label>
                    <label>
                        <input id="priority-above" type="radio" name="priority" value="1" /> Above
                    </label>
                </div>

            </div>

            <canvas id="tileset"></canvas>
            <button id="save-tileset" type="button">Save</button>
            <hr />
            <div id="tileset-json" class="well">

            </div>
        </div>
    </div>
</div>

@Scripts.Render("~/bundles/game")

@section scripts{
    <script>
        //for intellisence
        /// <reference path="/scripts/game-classes.js" />


        //layer draws all the tiles in a grid.
        function Layer(w, h) {
            var that = this;
            //2d array of tiles
            this.tiles = new Array2D(w, h);
            //canvas for the layer where the tiles will be drawn
            this.backbuffer = document.createElement('canvas');

            //get the context to draw on
            var _ctx = this.backbuffer.getContext('2d');

            //resize layer
            this.resizeLayer = function (x, y) {
                //if we resize the layer, create a new 2d array.
                //TODO: improve this by keeping original content. create new array and copy data
                that.tiles = new Array2D(x, y);
                //resize the backbuffer to the size of the layer
                that.backbuffer.width = x * TILE_W;
                that.backbuffer.height = y * TILE_H;
            }

            //renders a particular tileset to the backbuffer
            this.draw = function (tileset) {

                //clear
                _ctx.clearRect(0, 0, that.backbuffer.width, that.backbuffer.height);

                //render the layer onto the backbuffer
                for (var i = 0; i < that.tiles.length; i++) {
                    for (var j = 0; j < that.tiles[i].length; j++) {
                        var tile = that.tiles[i][j];
                        if (tile != undefined && tile != null) {
                            //draw tile
                            _ctx.drawImage(tileset.getImage(tile.set),
                                tile.srcX * TILE_W, tile.srcY * TILE_H, TILE_W, TILE_H,
                                i * TILE_W, j * TILE_H, TILE_W, TILE_H);
                        }
                    }
                }
            }
        }

        //tileset tile info. contains the info to be copied to the map as the map's tile info
        function TileSetTileInfo() {
            //0 allows all direction
            this.directions = 0;
            //higher priority gets drawn on top of all other tiles below it
            this.priority = 0;
        }

        //map tile info. settings for the map rendering engine
        function MapTileInfo() {
            this.srcX = 0;
            this.srcY = 0;
            this.set = 0;
            //0 allows all direction
            this.directions = 0;
            //higher priority gets drawn on top of all other tiles below it
            this.priority = 0;
        }

        //tileset tile
        function TileSet(name, onload) {
            var _self = this;
            this.name = name;
            this.frames = 1;
            this.image = new Image();
            this.tiles = new Array2D(0, 0);
            this.size = new Size();

            //load a tileset
            $.getJSON('/resources/tilesets/' + name + '.json', {}, function (data) {
                //set properties
                _self.image = new Image();
                _self.image.onload = function () {

                    //get number of tiles. frames divide the x based on how many frames there are
                    var x = (_self.image.width / TILE_W) / data.frames;
                    var y = _self.image.height / TILE_H;

                    //create tiles
                    _self.tiles = new Array2D(x, y);

                    //fill tiles with tile infos
                    for (var i = 0; i < x; i++) {
                        for (var j = 0; j < y; j++) {
                            var tileInfo = new TileSetTileInfo();

                            _self.tiles[i][j] = tileInfo;

                            if (data.tiles != undefined) {
                                //get the settings from the json tiles
                                var tileData = data.tiles[i][j];
                                //set the settings
                                tileInfo.directions = tileData.directions;
                                tileInfo.priority = tileData.priority;
                            }
                            //tileInfo.directions = DIRECTION_ALL;
                        }
                    }

                    //set size in grid
                    _self.size.width = x;
                    _self.size.height = y;

                    //call callback
                    if (typeof onload == 'function') {
                        onload();
                    }
                };

                //load image
                _self.image.src = '/resources/tilesets/' + name + '.png';


            });

        }

        //draws the tileset and allows the user to select a tile to draw on the map
        function TileSetEngine() {
            var that = this;

            var _tileset = document.getElementById('tileset');
            var _ctx = _tileset.getContext("2d");


            //where the mouse is over the grid
            var _hover = new Point(0, 0);
            var _mouseDown = false;
            this.selectedSet = -1;


            //selection. x,y and w,h
            this.selectX = 0;
            this.selectY = 0;
            this.selectW = 1;
            this.selectH = 1;
            this.selectedTile = null;

            //our tilesets
            this.sets = [];

            //on mouse move, calculate the grid x,y coord based on mouse pos
            $('#tileset').mousemove(function (e) {
                _hover.x = Math.floor(e.offsetX / TILE_W);
                _hover.y = Math.floor(e.offsetY / TILE_H);

                if (_mouseDown) {
                    //our select W, H will increase or descrease, depending on where we placed the selection
                    var sizeW = (_hover.x + 1) - that.selectX;
                    var sizeH = (_hover.y + 1) - that.selectY;

                    that.selectW = sizeW;
                    that.selectH = sizeH;
                }
            });

            //when mouse is clicked, take position and plop the tile there
            $('#tileset').mousedown(function (e) {

                //reset the select size
                that.selectW = 1;
                that.selectH = 1;

                //select the brush by default
                $('#toolbar-commands .brush').button('toggle');
                
                //mouse is down
                _mouseDown = true;

                //place selection here
                that.selectX = Math.floor(e.offsetX / TILE_W);
                that.selectY = Math.floor(e.offsetY / TILE_H);

                //get the selected tile info
                that.selectedTile = that.getTile(that.selectX, that.selectY);
                console.log(that.selectedTile);

                populateTileSettings();
            });

            //mouse was released
            $('#tileset').mouseup(function (e) {
                _mouseDown = false;
            });

            //directional checkboxes
            $('#direction-up').click(function () {
                if (that.selectedTile != null) {
                    var checked = $(this).prop('checked');
                    //bitwise operations
                    setDirections(DIRECTION_UP, checked);

                }
            });

            //directional checkboxes
            $('#direction-right').click(function () {
                if (that.selectedTile != null) {
                    var checked = $(this).prop('checked');
                    //bitwise operations
                    setDirections(DIRECTION_RIGHT, checked);

                }
            });

            //directional checkboxes
            $('#direction-down').click(function () {
                if (that.selectedTile != null) {
                    var checked = $(this).prop('checked');
                    //bitwise operations
                    setDirections(DIRECTION_DOWN, checked);

                }
            });

            //directional checkboxes
            $('#direction-left').click(function () {
                if (that.selectedTile != null) {
                    var checked = $(this).prop('checked');
                    //bitwise operations
                    setDirections(DIRECTION_LEFT, checked);
                    
                }
            });

            //handle priority click
            $('#tileset-priority input[type="radio"]').click(function () {

                //get all selected tiles
                var tiles = that.getSelectedTiles();
                for (var i = 0; i < tiles.length; i++) {
                    var tile = tiles[i];

                    tile.priority = $(this).val();

                }

            });

            //save the json data
            $('#save-tileset').click(function () {
                var set = that.getSet();

                var obj = {
                    name: set.name,
                    frames: set.frames,
                    tiles: set.tiles
                }

                $('#tileset-json').html(JSON.stringify(obj));
            });

            //tileset is selected
            $('#tileset-select').change(function () {
                selectTileset(parseInt($(this).val()));
            });

            //returns an array of selected tiles
            this.getSelectedTiles = function () {
                var tiles = [];
                for (var i = 0; i < that.selectW; i++) {
                    for (var j = 0; j < that.selectH; j++) {
                        //add tile to list of selected tiles
                        tiles.push(that.getTile(that.selectX + i, that.selectY + j));
                    }
                }

                return tiles;
            }

            //gets the current tileset
            this.getSet = function () {
                return that.sets[that.selectedSet];
            }

            //gets the currently selected set's image
            this.getImage = function (index) {
                var i = (index != undefined ? index : that.selectedSet);
                return that.sets[i].image;
            }

            //gets the selected tile of the current tile set
            this.getTile = function (x, y) {
                return that.sets[that.selectedSet].tiles[x][y];
            }

            //adds or removes a direction for all selected tiles
            function setDirections(direction, checked) {
                
                //get all selected tiles
                var tiles = that.getSelectedTiles();
                for (var i = 0; i < tiles.length; i++) {
                    var tile = tiles[i];

                    //bitwise operations
                    if (checked) {
                        tile.directions |= direction;
                    }
                    else {
                        tile.directions &= ~direction;
                    }

                }
            }

            //populate tile settings UI
            function populateTileSettings() {
                //get the selected tile and populate
                if (that.selectedTile != null) {
                    $('#direction-up').prop('checked', that.selectedTile.directions & DIRECTION_UP);
                    $('#direction-right').prop('checked', that.selectedTile.directions & DIRECTION_RIGHT);
                    $('#direction-down').prop('checked', that.selectedTile.directions & DIRECTION_DOWN);
                    $('#direction-left').prop('checked', that.selectedTile.directions & DIRECTION_LEFT);

                    //set priority
                    $('#tileset-priority input[type="radio"][value="' + that.selectedTile.priority + '"]').prop('checked', true);
                }
            }

            //function load images
            function loadTileset() {
                               
                //add set to array
                that.sets.push(new TileSet('001-Grassland01', function () { selectTileset(0); }));
                that.sets.push(new TileSet('001-G_Water01'));

                //add items to select list
                for (var i = 0; i < that.sets.length; i++) {
                    var set = that.sets[i];

                    var opt = new Option(set.name, i);
                    $('#tileset-select').append(opt);
                }
                
            }

            //selects the current image
            function selectTileset(index) {
                that.selectedSet = index;
                //set tileset
                var set = that.getSet();
                //image has loaded. set tileset size to size of image
                adjustTileSet(set.size.width, set.size.height);
            }

            //generates a grid of map tiles
            function adjustTileSet(w, h) {

                _tileset.width = w * TILE_W;
                _tileset.height = h * TILE_H;
            }

            //draw map
            function draw() {
                //clear
                _ctx.clearRect(0, 0, _tileset.width, _tileset.height);

                if (that.selectedSet >= 0) {
                    //draw the image
                    var image = that.getImage();
                    _ctx.drawImage(image,
                        0, 0, image.width, image.height,
                        0, 0, image.width, image.height);
                }

                //draw the tile square where the selection is
                _ctx.strokeStyle = "rgb(0,128,255)";
                _ctx.strokeRect(that.selectX * TILE_W, that.selectY * TILE_H, that.selectW * TILE_W, that.selectH * TILE_H);


                //draw the tile square where the mouse is
                _ctx.fillStyle = "rgba(0,0,0, 0.5)";
                _ctx.fillRect(_hover.x * TILE_W, _hover.y * TILE_H, TILE_W, TILE_H);

                //get frame
                window.requestAnimationFrame(draw);
            }

            //load tileset
            loadTileset();

            ////initial map size
            //adjustTileSet(1, 1);

            //get frame
            window.requestAnimationFrame(draw);

        };


        (function () {
            var _tileSetEngine = new TileSetEngine();
            var _canvas = document.getElementById('map');
            var _ctx = _canvas.getContext("2d");
            
            //size of map (in grid units)
            var _mapSize = new Size(20, 12);

            //where the mouse is over the grid
            var _hover = new Point(0, 0);

            var _layers = [];
            var _activeLayer = 0;
            var _mouseDown = false;
            var _mouseOver = false;
            var _oldX = null;
            var _oldY = null;

            var _command = 'brush';

            //generate a map of a particular size
            $('#generate').click(function () {
                var w = parseInt($('#map-width').val());
                var h = parseInt($('#map-height').val());

                //create grid
                adjustMap(w, h);
            });

            //on mouse move, calculate the grid x,y coord based on mouse pos
            $('#map').mousemove(function (e) {
                _hover.x = Math.floor(e.offsetX / TILE_W);
                _hover.y = Math.floor(e.offsetY / TILE_H);

                if (_mouseDown) {
                    //execute the selected draw command
                    executeDrawCommand(e);
                }
            });

            //when mouse is clicked, take position and plop the tile there
            $('#map').mousedown(function (e) {
                _mouseDown = true;

                //execute the selected draw command
                executeDrawCommand(e);

            });

            //mouse up
            $('#map').mouseup(function (e) {
                _mouseDown = false;
                _oldX = null;
                _oldY = null;
            });

            $('#map').mouseenter(function (e) {
                _mouseOver = true;
            });

            $('#map').mouseleave(function (e) {
                _mouseOver = false;
            });

            //handle check event on layers
            $('#toolbar-layers input[type="radio"]').change(function () {
                _activeLayer = parseInt($(this).val());
            });

            //handle check event on layers
            $('#toolbar-commands input[type="radio"]').change(function () {
                _command = $(this).val();
            });

            $('#save-map').click(function () {
                //take the layers and generate a map.

                var tilesets = [];
                var layers = [];
                
                //create the tilesets
                for (var i = 0; i < _tileSetEngine.sets.length; i++) {
                    var set = _tileSetEngine.sets[i];

                    tilesets.push({
                        src: set.image.src,
                        frames: set.frames,
                        size: set.size
                    });
                }

                //create the layers
                for (var i = 0; i < _layers.length; i++) {
                    var layer = _layers[i];

                    layers.push({
                        tiles: layer.tiles
                    });
                }
                               

                //build map info
                var obj = {
                    size: _mapSize,
                    tilesets: tilesets,
                    layers: layers
                }

                $('#map-json').html(JSON.stringify(obj));
            });

            //execute the selected draw command
            function executeDrawCommand(e) {
                if (_activeLayer < 0) {
                    return;
                }

                var x = Math.floor(e.offsetX / TILE_W);
                var y = Math.floor(e.offsetY / TILE_H);

                if (_command == 'brush') {
                    //place the tile on the map
                    placeTile(x, y);
                }
                else if (_command == 'erase') {
                    //erase the tile
                    eraseTile(x, y);
                }
                else if (_command == 'fill') {
                    //fill with tile
                    fillLayer();
                }
                else if (_command == 'clear') {
                    //clear all tiles
                    clearLayer();
                }

                //update old pos so we dont update again until mouse is over next tile
                _oldX = x;
                _oldY = y;
            }

            //places a tile on the map at the x,y coord where the mouse is
            function placeTile(x, y) {

                if (_oldX != x || _oldY != y) {
                    //get the active layer
                    var layer = _layers[_activeLayer];

                    //loop and draw all tiles
                    for (var i = 0; i < _tileSetEngine.selectW; i++) {
                        for (var j = 0; j < _tileSetEngine.selectH; j++) {

                            //make sure x + i and y + j do not go out of map bounds
                            if (x + i > _mapSize.width - 1 || y + j > _mapSize.height) {
                                //skip over this iteration because it goes out of bounds
                                continue;
                            }

                            //add coords
                            var mapTile = new MapTileInfo();
                            //get the tile info for each tile in the matrix
                            var tileInfo = _tileSetEngine.getTile(_tileSetEngine.selectX + i, _tileSetEngine.selectY + j);
                            //set info
                            mapTile.srcX = _tileSetEngine.selectX + i;
                            mapTile.srcY = _tileSetEngine.selectY + j;
                            mapTile.set = _tileSetEngine.selectedSet;
                            mapTile.directions = tileInfo.directions;
                            mapTile.priority = tileInfo.priority;

                            layer.tiles[x + i][y + j] = mapTile;
                        }
                    }




                }
            }

            //fills the entire layer with the selected tile. overwrites everything on that layer
            function fillLayer() {
                //get the active layer
                var layer = _layers[_activeLayer];

                for (var i = 0; i < layer.tiles.length; i++) {
                    for (var j = 0; j < layer.tiles[i].length; j++) {

                        //add coords
                        var mapTile = new MapTileInfo();
                        //get the tile info for each tile in the matrix
                        var tileInfo = _tileSetEngine.getTile(_tileSetEngine.selectX, _tileSetEngine.selectY);
                        //set info
                        mapTile.srcX = _tileSetEngine.selectX;
                        mapTile.srcY = _tileSetEngine.selectY;
                        mapTile.set = _tileSetEngine.selectedSet;
                        mapTile.directions = tileInfo.directions;
                        mapTile.priority = tileInfo.priority;

                        layer.tiles[i][j] = mapTile;

                    }
                }
            }

            //removes a tile from the grid
            function eraseTile(x, y) {

                if (_oldX != x || _oldY != y) {
                    //get the active layer
                    var layer = _layers[_activeLayer];

                    //remove coords
                    delete layer.tiles[x][y];

                }
            }

            //clears the entire layer
            function clearLayer() {
                //get the active layer
                var layer = _layers[_activeLayer];

                for (var i = 0; i < layer.tiles.length; i++) {
                    for (var j = 0; j < layer.tiles[i].length; j++) {

                        //add coords
                        delete layer.tiles[i][j];

                    }
                }
            }

            //generates a grid of map tiles
            function adjustMap(w, h) {
                _mapSize.width = w;
                _mapSize.height = h;

                _canvas.width = w * TILE_W;
                _canvas.height = h * TILE_H;

                for (var i = 0; i < _layers.length; i++) {
                    var layer = _layers[i];
                    //resize layer
                    layer.resizeLayer(w, h);
                }
            }

            //draw map
            function draw() {
                //clear
                _ctx.fillStyle = "rgb(0,0,0)";
                _ctx.fillRect(0, 0, _canvas.width, _canvas.height);

                //render the contents of the array to a back buffer, one per layer
                for (var i = 0; i < _layers.length; i++) {
                    var layer = _layers[i];

                    //draw this tileset
                    layer.draw(_tileSetEngine);
                    //draw layer
                    _ctx.globalAlpha = 0.3;
                    if (i == _activeLayer || _activeLayer < 0) {
                        _ctx.globalAlpha = 1;
                    }

                    //draw the layer's backbuffer
                    _ctx.drawImage(layer.backbuffer,
                        0, 0, layer.backbuffer.width, layer.backbuffer.height,
                        0, 0, _canvas.width, _canvas.height);

                }
                //reset global alpha
                _ctx.globalAlpha = 1;

                //draw the select square if we are on a valid layer
                if (_activeLayer > -1 && _mouseOver) {

                    if (_command == 'brush') {
                        //draw the tile preview based on the selected tileset
                        _ctx.drawImage(_tileSetEngine.getImage(),
                            _tileSetEngine.selectX * TILE_W, _tileSetEngine.selectY * TILE_H, _tileSetEngine.selectW * TILE_W, _tileSetEngine.selectH * TILE_H,
                            _hover.x * TILE_W, _hover.y * TILE_H, _tileSetEngine.selectW * TILE_W, _tileSetEngine.selectH * TILE_H);
                    }
                    else {
                        //draw the tile square where the mouse is
                        //draw the tile preview based on the selected tileset
                        _ctx.drawImage(_tileSetEngine.getImage(),
                            _tileSetEngine.selectX * TILE_W, _tileSetEngine.selectY * TILE_H, TILE_W, TILE_H,
                            _hover.x * TILE_W, _hover.y * TILE_H, TILE_W, TILE_H);
                    }
                }

                //get frame
                window.requestAnimationFrame(draw);
            }

            //create layers
            _layers.push(new Layer(_mapSize.width, _mapSize.height));
            _layers.push(new Layer(_mapSize.width, _mapSize.height));
            _layers.push(new Layer(_mapSize.width, _mapSize.height));

            //initial map size
            adjustMap(_mapSize.width, _mapSize.height);

            //get frame
            window.requestAnimationFrame(draw);

        })();
    </script>
}


<div></div>